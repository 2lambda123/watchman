"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[9874],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return s},MDXProvider:function(){return u},mdx:function(){return x},useMDXComponents:function(){return p},withMDXComponents:function(){return c}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},i.apply(this,arguments)}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function m(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){return function(n){var t=p(n.components);return r.createElement(e,i({},n,{components:t}))}},p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,s=m(e,["components","mdxType","originalType","parentName"]),c=p(t),u=a,f=c["".concat(l,".").concat(u)]||c[u]||d[u]||i;return t?r.createElement(f,o(o({ref:n},s),{},{components:t})):r.createElement(f,o({ref:n},s))}));function x(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=f;var o={};for(var m in n)hasOwnProperty.call(n,m)&&(o[m]=n[m]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var s=2;s<i;s++)l[s]=t[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},18183:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return m},default:function(){return d},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return p}});var r=t(83117),a=t(80102),i=(t(67294),t(3905)),l=["components"],o={title:"Simple Pattern Syntax",category:"Queries"},m=void 0,s={unversionedId:"simple-query",id:"simple-query",title:"Simple Pattern Syntax",description:"Simple patterns follow a more traditional UNIX command line approach of using",source:"@site/docs/simple-query.md",sourceDirName:".",slug:"/simple-query",permalink:"/watchman/docs/simple-query",draft:!1,editUrl:"https://github.com/facebook/watchman/tree/main/website/docs/simple-query.md",tags:[],version:"current",frontMatter:{title:"Simple Pattern Syntax",category:"Queries"},sidebar:"tutorialSidebar",previous:{title:"Source Control Aware Queries",permalink:"/watchman/docs/scm-query"},next:{title:"allof",permalink:"/watchman/docs/expr/allof"}},c={},p=[{value:"Simple Pattern syntax",id:"simple-pattern-syntax",level:2}],u={toc:p};function d(e){var n=e.components,t=(0,a.Z)(e,l);return(0,i.mdx)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Simple patterns follow a more traditional UNIX command line approach of using\ncommand line switches to indicate the nature of the pattern match. When simple\npatterns are used, the result set unconditionally includes all core file\nmetadata fields. They are described in more detail below."),(0,i.mdx)("h2",{id:"simple-pattern-syntax"},"Simple Pattern syntax"),(0,i.mdx)("p",null,"Where you see ",(0,i.mdx)("inlineCode",{parentName:"p"},"[patterns]")," in the command syntax for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"find"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"since")," and\n",(0,i.mdx)("inlineCode",{parentName:"p"},"trigger")," commands, we allow filename patterns that match according the\nfollowing rules:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"We maintain an ",(0,i.mdx)("em",{parentName:"li"},"inclusion")," and an ",(0,i.mdx)("em",{parentName:"li"},"exclusion")," list. As the arguments are\nprocessed we'll accumulate them in one or the other. By default they are\naccumulated into the ",(0,i.mdx)("em",{parentName:"li"},"inclusion")," list."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"-X")," causes any subsequent items to be placed into the ",(0,i.mdx)("em",{parentName:"li"},"exclusion")," list"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"-I")," causes any subsequent items to be placed into the ",(0,i.mdx)("em",{parentName:"li"},"inclusion")," list"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"--")," indicates the end of the set of patterns"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"-p")," indicates that the following pattern should use ",(0,i.mdx)("inlineCode",{parentName:"li"},"pcre")," as the expression\nterm. This is reset after generating the next term."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"-P")," indicates that the following pattern should use ",(0,i.mdx)("inlineCode",{parentName:"li"},"ipcre")," as the expression\nterm and perform a case insensitive match. This is reset after generating the\nnext term."),(0,i.mdx)("li",{parentName:"ul"},"If neither ",(0,i.mdx)("inlineCode",{parentName:"li"},"-p")," nor ",(0,i.mdx)("inlineCode",{parentName:"li"},"-P")," were used, the generated term will use ",(0,i.mdx)("inlineCode",{parentName:"li"},"match")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"!")," followed by a space followed by a pattern will negate the sense of the\npattern match generating a ",(0,i.mdx)("inlineCode",{parentName:"li"},"not")," term.")),(0,i.mdx)("p",null,'Any elements in the inclusion list will match; they are composed together using\nan "anyof" term.'),(0,i.mdx)("p",null,"The inclusion list and exclusion lists are composed using the logic\n",(0,i.mdx)("inlineCode",{parentName:"p"},"(NOT anyof exclusion) AND (anyof inclusion)"),"."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"}," '*.c'\n")),(0,i.mdx)("p",null,"Generates a file expression:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'["match", "*.c", "wholename"]\n')),(0,i.mdx)("p",null,"A list:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"'*.js' '*.css'\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'["anyof",\n  ["match", "*.js", "wholename"],\n  ["match", "*.css", "wholename"]\n]\n')),(0,i.mdx)("p",null,"An example of how the exclusion list syntax works:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"}," -X '*.c' -I '*main*'\n")),(0,i.mdx)("p",null,"Generates:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'["allof",\n  ["not", ["match", "*.c", "wholename"]],\n  ["match", "*main*", "wholename"]\n]\n')))}d.isMDXComponent=!0}}]);