"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[7882],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return m},MDXProvider:function(){return h},mdx:function(){return g},useMDXComponents:function(){return p},withMDXComponents:function(){return d}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var m=a.createContext({}),d=function(e){return function(t){var n=p(t.components);return a.createElement(e,r({},t,{components:n}))}},p=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(m.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=i,u=d["".concat(o,".").concat(h)]||d[h]||c[h]||r;return n?a.createElement(u,l(l({ref:t},m),{},{components:n})):a.createElement(u,l({ref:t},m))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var m=2;m<r;m++)o[m]=n[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},10401:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return l},metadata:function(){return m},toc:function(){return p}});var a=n(83117),i=n(80102),r=(n(67294),n(3905)),o=["components"],l={title:"trigger",category:"Commands"},s=void 0,m={unversionedId:"cmd/trigger",id:"cmd/trigger",title:"trigger",description:"The trigger command will create or replace a trigger.",source:"@site/docs/cmd/trigger.md",sourceDirName:"cmd",slug:"/cmd/trigger",permalink:"/watchman/docs/cmd/trigger",draft:!1,editUrl:"https://github.com/facebook/watchman/tree/main/website/docs/cmd/trigger.md",tags:[],version:"current",frontMatter:{title:"trigger",category:"Commands"},sidebar:"tutorialSidebar",previous:{title:"trigger-list",permalink:"/watchman/docs/cmd/trigger-list"},next:{title:"unsubscribe",permalink:"/watchman/docs/cmd/unsubscribe"}},d={},p=[{value:"Extended syntax",id:"extended-syntax",level:3},{value:"Simple syntax",id:"simple-syntax",level:3},{value:"Environment for trigger commands",id:"environment-for-trigger-commands",level:3},{value:"Relative roots",id:"relative-roots",level:3}],h={toc:p};function c(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.mdx)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"The trigger command will create or replace a trigger."),(0,r.mdx)("p",null,"A trigger is a saved incremental query over a watched root. When files change\nthat match the query expression, Watchman will spawn a process and pass\ninformation about the changed files to it."),(0,r.mdx)("p",null,"Triggered processes are spawned by the Watchman server process that runs in the\nbackground; they do not have access to your terminal and their output is\nredirected (by default) to the Watchman log file."),(0,r.mdx)("p",null,"Watchman waits for the filesystem to settle before processing any triggers,\nbatching the list of changed files together before invoking the registered\ncommand. You can adjust the settle period via the ",(0,r.mdx)("inlineCode",{parentName:"p"},".watchmanconfig")," file."),(0,r.mdx)("p",null,"Note that deleted files are counted as changed files and are passed the command\nin exactly the same way as changed-but-existing files."),(0,r.mdx)("p",null,"Watchman will only run a single instance of the trigger process at a time. That\navoids fork-bomb style behavior in cases where your trigger also modifies files.\nWhen the process terminates, watchman will re-evaluate the trigger criteria\nbased on the clock at the time the process was last spawned; if a file list is\ngenerated watchman will spawn a new child with the files that changed in the\nmeantime."),(0,r.mdx)("p",null,"Unless ",(0,r.mdx)("inlineCode",{parentName:"p"},"no-save-state")," is in use, triggers are saved and re-established across a\nWatchman process restart. If you had triggeres saved prior to upgrading to\nWatchman 2.9.7, those triggers will be forgotten as you upgrade past version\n2.9.7; you will need to re-register them."),(0,r.mdx)("p",null,"There are two syntaxes for registering triggers; a simple syntax that allows\nvery simple trigger configuration with some reasonable defaults, and a second\nextended syntax which is available since Watchman version 2.9.7."),(0,r.mdx)("p",null,"The simple syntax is implemented in terms of the extended syntax and is\npreserved for backwards compatibility with older clients."),(0,r.mdx)("h3",{id:"extended-syntax"},"Extended syntax"),(0,r.mdx)("p",null,(0,r.mdx)("em",{parentName:"p"},"Since 2.9.7.")),(0,r.mdx)("p",null,"You may use the extended JSON trigger definition syntax detailed below. It\nprovides more control over how the triggered commands are invoked than was\npossible in earlier versions."),(0,r.mdx)("p",null,"JSON:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'["trigger", "/path/to/dir", <triggerobj>]\n')),(0,r.mdx)("p",null,"Where ",(0,r.mdx)("inlineCode",{parentName:"p"},"triggerobj")," is a trigger configuration object with the fields defined\nbelow."),(0,r.mdx)("p",null,"Here's an example trigger specified via the CLI that will cause ",(0,r.mdx)("inlineCode",{parentName:"p"},"make")," to be run\nwhenever assets or sources are changed:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ watchman -j <<-EOT\n["trigger", "/path/to/root", {\n  "name": "assets",\n  "expression": ["pcre", "\\.(js|css|c|cpp)$"],\n  "command": ["make"]\n}]\nEOT\n')),(0,r.mdx)("p",null,"The possible trigger object properties are:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"name")," defines the name of the trigger. You may use this name to remove the\ntrigger later. Registering a different trigger with the same name as an\nexisting trigger will implicitly delete the old trigger and then register the\nnew one, causing the trigger expression to be evaluated for the whole tree.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"command")," specifies the command to invoke. It must be an array of string\nvalues; this will form the argv array of the trigger process. When the trigger\nis spawned, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"$PATH")," of the Watchman process will be used to locate the\ncommand. If you have changed your ",(0,r.mdx)("inlineCode",{parentName:"p"},"$PATH")," since the Watchman process was\nstarted, Watchman won't be able to see your new ",(0,r.mdx)("inlineCode",{parentName:"p"},"$PATH"),". If you are\nregistering trigger that runs something from an unusual or non-default\nlocation, it is recommended that you specify the full path to that command. If\nyou are registering a trigger script that can be found in the watched root,\njust specify the path relative to the root.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"append_files")," is an optional boolean parameter; if enabled, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"command"),"\narray will have the set of matching file names appended when the trigger is\ninvoked. System limits such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"sysconf(_SC_ARG_MAX)")," and/or ",(0,r.mdx)("inlineCode",{parentName:"p"},"RLIMIT_STACK"),"\nset an upper bound on the size of the parameters and environment that are\npassed to a spawned process. Watchman will try to ensure that the command is\nrunnable by keeping the number of file name arguments below the system limits.\nIf the full set cannot be passed to the process, Watchman will pass as many as\nit thinks will fit and omit the rest. When this argument list truncation\noccurs, Watchman will export ",(0,r.mdx)("inlineCode",{parentName:"p"},"WATCHMAN_FILES_OVERFLOW=true")," into the\nenvironment so that the child process can determine that this has happened.\nWatchman cannot break the arguments apart and run multiple processes for each\nargument batch; for that functionality, use ",(0,r.mdx)("inlineCode",{parentName:"p"},"xargs(1)")," for the ",(0,r.mdx)("inlineCode",{parentName:"p"},"command")," and\nset the ",(0,r.mdx)("inlineCode",{parentName:"p"},"stdin")," property to ",(0,r.mdx)("inlineCode",{parentName:"p"},"NAME_PER_LINE"),".")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"expression")," accepts a query expression. The expression is applied to the list\nof changed files to generate the set of files that are relevant to this\ntrigger. If no files match, the command will not be invoked. Omitting the\nexpression will match all changed files.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"stdin")," specifies how stdin should be configured for the command invocation.\nYou may set the value of this property to one of the following:"),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"the string value ",(0,r.mdx)("inlineCode",{parentName:"p"},"/dev/null")," - sets stdin to read from ",(0,r.mdx)("inlineCode",{parentName:"p"},"/dev/null"),". This is\nthe default and will be used if you omit the ",(0,r.mdx)("inlineCode",{parentName:"p"},"stdin")," property.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"an array value will be interpreted as a list of field names. When the\ncommand is invoked, Watchman will generate an array of JSON objects that\ncontain those field names on stdin. For example, if ",(0,r.mdx)("inlineCode",{parentName:"p"},"stdin")," is set to\n",(0,r.mdx)("inlineCode",{parentName:"p"},'["name", "size"]'),", stdin will be a JSON array containing the list of\nchanged files, represented as objects with the ",(0,r.mdx)("inlineCode",{parentName:"p"},"name")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"size")," properties:\n",(0,r.mdx)("inlineCode",{parentName:"p"},'[{"name": "filename.txt", "size": 123}]'),". The list of valid fields is the\nsame as the same as that documented in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"query")," command. Just as with the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"query")," command, if the field list is comprised of a single field then the\nJSON will be an array of those field values. For instance, if you set\n",(0,r.mdx)("inlineCode",{parentName:"p"},"stdin")," to ",(0,r.mdx)("inlineCode",{parentName:"p"},'["name"]')," the JSON will be of the form ",(0,r.mdx)("inlineCode",{parentName:"p"},'["filename.txt"]'),"\ninstead of ",(0,r.mdx)("inlineCode",{parentName:"p"},'[{"name": "filename.txt"}]'),".")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"the string value ",(0,r.mdx)("inlineCode",{parentName:"p"},"NAME_PER_LINE")," will cause Watchman to generate a list of\nfile names on stdin, one name per line. No quoting will be applied to the\nnames, and they may contain spaces.")))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"stdout")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"stderr")," control the output and error streams. If omitted, the\ncorresponding stream will be inherited from the Watchman process, which\ntypically means that the command output/error stream will show up in the\nWatchman log file. If specified, the value must be a string:"),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},">path/to/file")," - causes output to redirected to the specified file. The\npath is relative to the watched root, and will be truncated prior to being\nwritten to, if it exists, or created if it does not exist.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},">>path/to/file")," - causes output to redirected to the specified file. The\npath is relative to the watched root. If the file already exists then it\nwill be appended to. The file will be created if it does not exist.")))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"max_files_stdin")," specifies a limit on the number of files reported on stdin\nwhen stdin is set to hold the set of matched files. If the number of files\nthat matched exceeds this limit, the input will be truncated to match this\nlimit and ",(0,r.mdx)("inlineCode",{parentName:"p"},"WATCHMAN_FILES_OVERFLOW=true")," will also be exported into the\nenvironment. The default, if omitted, is no limit.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"chdir")," can be used to specify the working directory that should be set prior\nto spawning the process. The default is to set the working directory to the\nwatched root. The value of this property is a string that will be interpreted\nrelative to the watched root. Note that changing the working dir does not\ncause the file names from the query result to be re-written: they will\n",(0,r.mdx)("em",{parentName:"p"},"always")," be relative to the watched root. The path to the root can be found in\nthe ",(0,r.mdx)("inlineCode",{parentName:"p"},"$WATCHMAN_ROOT")," environmental variable."))),(0,r.mdx)("h3",{id:"simple-syntax"},"Simple syntax"),(0,r.mdx)("p",null,"The simple syntax is easier to execute from the CLI than the JSON based extended\nsyntax, but doesn't allow all of the trigger options to be set. In only supports\nthe ",(0,r.mdx)("a",{parentName:"p",href:"/watchman/docs/simple-query"},"Simple Pattern Syntax")," for queries."),(0,r.mdx)("p",null,"From the command line:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"$ watchman -- trigger /path/to/dir triggername [patterns] -- [cmd]\n")),(0,r.mdx)("p",null,"Note that the first ",(0,r.mdx)("inlineCode",{parentName:"p"},"--")," is to distinguish watchman CLI switches from the second\n",(0,r.mdx)("inlineCode",{parentName:"p"},"--"),", which delimits patterns from the trigger command. This is only needed when\nusing the CLI, not when using the JSON protocol."),(0,r.mdx)("p",null,"JSON:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'["trigger", "/path/to/dir", "triggername", <patterns>, "--", <cmd>]\n')),(0,r.mdx)("p",null,"For example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"$ watchman -- trigger ~/www jsfiles '*.js' -- ls -l\n")),(0,r.mdx)("p",null,"Note the single quotes around the ",(0,r.mdx)("inlineCode",{parentName:"p"},"*.js"),"; if you omit them, your shell will\nexpand it to a list of file names and register those in the trigger. While this\nwould work, any ",(0,r.mdx)("inlineCode",{parentName:"p"},"*.js")," files that you add after registering the trigger will not\ncause the trigger to run."),(0,r.mdx)("p",null,"or in JSON:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'["trigger", "/home/wez/www", "jsfiles", "*.js", "--", "ls", "-l"]\n')),(0,r.mdx)("p",null,"The simple syntax is interpreted as a trigger object with the following\nsettings:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"name")," is set to the ",(0,r.mdx)("inlineCode",{parentName:"li"},"triggername")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"command")," is set to the ",(0,r.mdx)("inlineCode",{parentName:"li"},"<cmd>")," list"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"expression")," is generated from the ",(0,r.mdx)("inlineCode",{parentName:"li"},"<patterns>")," list using the rules laid out\nin ",(0,r.mdx)("a",{parentName:"li",href:"/watchman/docs/simple-query"},"Simple Pattern Syntax")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"append_files")," is set to ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"stdin")," is set to ",(0,r.mdx)("inlineCode",{parentName:"li"},'["name", "exists", "new", "size", "mode"]')),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"stdout")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"stderr")," will be set to output to the Watchman log file"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"max_files_stdin")," will be left unset")),(0,r.mdx)("p",null,"For this simple example, if ",(0,r.mdx)("inlineCode",{parentName:"p"},"~/www/scripts/foo.js")," is changed, watchman will\nchdir to ",(0,r.mdx)("inlineCode",{parentName:"p"},"~/www")," then invoke ",(0,r.mdx)("inlineCode",{parentName:"p"},"ls -l scripts/foo.js"),". Note that the output will\nshow up in the Watchman log file, not in your terminal."),(0,r.mdx)("h3",{id:"environment-for-trigger-commands"},"Environment for trigger commands"),(0,r.mdx)("p",null,"Since Watchman version 2.9.7, the following environment variables are set for\nall trigger commands, even those registered using the simple trigger syntax:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_FILES_OVERFLOW")," is set to ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")," if the number of files exceeds\neither the ",(0,r.mdx)("inlineCode",{parentName:"li"},"max_files_stdin")," limit or the system argument size limit."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_CLOCK")," is set to the current clock at the time of the trigger\ninvocation"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_SINCE")," is set to the clock value of the prior trigger invocation, or\nunset if this is the first trigger invocation."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_ROOT")," is set to the path to the watched root"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_TRIGGER")," is set to the name of the trigger"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_SOCK")," is set to the path to the Watchman socket, so that you can\nfigure out how to connect back to Watchman.")),(0,r.mdx)("h3",{id:"relative-roots"},"Relative roots"),(0,r.mdx)("p",null,(0,r.mdx)("em",{parentName:"p"},"Since 3.4.")),(0,r.mdx)("p",null,"Watchman supports optionally evaluating triggers with respect to a path within a\nwatched root. This is used with the ",(0,r.mdx)("inlineCode",{parentName:"p"},"relative_root")," parameter:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'["trigger", "/path/to/watched/root", {\n  "name": "relative-assets",\n  "expression": ["pcre", "\\.(js|css|c|cpp)$"],\n  "command": ["make"],\n  "relative_root": "project1"\n}]\n')),(0,r.mdx)("p",null,"Setting a relative root results in the following modifications to triggers:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Queries are evaluated with respect to the relative root. See\n",(0,r.mdx)("a",{parentName:"li",href:"/watchman/docs/file-query"},"File Queries")," for more."),(0,r.mdx)("li",{parentName:"ul"},"The current directory for triggered processes is set to the relative root,\nunless it is changed with ",(0,r.mdx)("inlineCode",{parentName:"li"},"chdir"),". If ",(0,r.mdx)("inlineCode",{parentName:"li"},"chdir")," is a relative path then it will\nbe evaluated with respect to the relative root. So, for the example trigger\nabove, if ",(0,r.mdx)("inlineCode",{parentName:"li"},"chdir")," is ",(0,r.mdx)("inlineCode",{parentName:"li"},'"subdir2"'),", the current directory for triggered ",(0,r.mdx)("inlineCode",{parentName:"li"},"make"),"\ninvocations is ",(0,r.mdx)("inlineCode",{parentName:"li"},"/path/to/watched/root/project1/subdir2"),"."),(0,r.mdx)("li",{parentName:"ul"},"In the environment, ",(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_ROOT")," is still set to the actual root."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"WATCHMAN_RELATIVE_ROOT")," is set to the full path of the relative root.")),(0,r.mdx)("p",null,"Relative roots behave similarly to a separate Watchman watch on the\nsubdirectory, without any of the system overhead that that imposes. This is\nuseful for large repositories, where your script or tool is only interested in a\nparticular directory inside the repository."))}c.isMDXComponent=!0}}]);