"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[256],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return c},MDXProvider:function(){return m},mdx:function(){return b},useMDXComponents:function(){return p},withMDXComponents:function(){return d}});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},a.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=i.createContext({}),d=function(e){return function(n){var t=p(n.components);return i.createElement(e,a({},n,{components:t}))}},p=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},m=function(e){var n=p(e.components);return i.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(o,".").concat(m)]||d[m]||u[m]||a;return t?i.createElement(h,s(s({ref:n},c),{},{components:t})):i.createElement(h,s({ref:n},c))}));function b(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<a;c++)o[c]=t[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},71288:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var i=t(83117),r=t(80102),a=(t(67294),t(3905)),o=["components"],s={title:"NodeJS",category:"Invocation",sidebar_position:6},l=void 0,c={unversionedId:"nodejs",id:"nodejs",title:"NodeJS",description:"To install the nodejs client:",source:"@site/docs/nodejs.md",sourceDirName:".",slug:"/nodejs",permalink:"/watchman/docs/nodejs",draft:!1,editUrl:"https://github.com/facebook/watchman/tree/main/website/docs/nodejs.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"NodeJS",category:"Invocation",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"C++ Client",permalink:"/watchman/docs/cppclient"},next:{title:"Configuration Files",permalink:"/watchman/docs/config"}},d={},p=[{value:"Checking for watchman availability",id:"checking-for-watchman-availability",level:2},{value:"Initiating a watch",id:"initiating-a-watch",level:2},{value:"Subscribing to changes",id:"subscribing-to-changes",level:2},{value:"Subscribing only to changed files",id:"subscribing-only-to-changed-files",level:3},{value:"NodeJS API Reference",id:"nodejs-api-reference",level:2},{value:"Methods",id:"methods",level:2},{value:"client.capabilityCheck(options, done)",id:"clientcapabilitycheckoptions-done",level:3},{value:"client.command(args , done)",id:"clientcommandargs--done",level:3},{value:"client.end()",id:"clientend",level:3},{value:"Events",id:"events",level:2},{value:"Event: &#39;connect&#39;",id:"event-connect",level:3},{value:"Event: &#39;error&#39;",id:"event-error",level:3},{value:"Event: &#39;end&#39;",id:"event-end",level:3},{value:"Event: &#39;log&#39;",id:"event-log",level:3},{value:"Event: &#39;subscription&#39;",id:"event-subscription",level:3}],m={toc:p};function u(e){var n=e.components,t=(0,r.Z)(e,o);return(0,a.mdx)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"To install the nodejs client:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-bash"},"$ npm install fb-watchman\n")),(0,a.mdx)("p",null,"and to import it and create a client instance:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"var watchman = require('fb-watchman');\nvar client = new watchman.Client();\n")),(0,a.mdx)("p",null,"This documentation assumes that you are using the latest available version of\nthe ",(0,a.mdx)("inlineCode",{parentName:"p"},"fb-watchman")," package published to the npm repository."),(0,a.mdx)("h2",{id:"checking-for-watchman-availability"},"Checking for watchman availability"),(0,a.mdx)("p",null,"The client can be installed without requiring that the service is installed. It\nis important to handle lack of availability and also to test whether the\ninstalled service supports the ",(0,a.mdx)("a",{parentName:"p",href:"/watchman/docs/capabilities"},"capabilities")," required by your\napplication."),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"capabilityCheck")," method issues a ",(0,a.mdx)("a",{parentName:"p",href:"/watchman/docs/cmd/version"},"version")," command to query\nthe capabilities of the server."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"var watchman = require('fb-watchman');\nvar client = new watchman.Client();\nclient.capabilityCheck({optional:[], required:['relative_root']},\n  function (error, resp) {\n    if (error) {\n      // error will be an Error object if the watchman service is not\n      // installed, or if any of the names listed in the `required`\n      // array are not supported by the server\n      console.error(error);\n    }\n    // resp will be an extended version response:\n    // {'version': '3.8.0', 'capabilities': {'relative_root': true}}\n    console.log(resp);\n  });\n")),(0,a.mdx)("h2",{id:"initiating-a-watch"},"Initiating a watch"),(0,a.mdx)("p",null,"Almost every operation in watchman revolves around watching a directory tree.\nYou can repeatedly ask to watch the same directory without error; watchman will\nre-use an existing watch."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"var watchman = require('fb-watchman');\nvar client = new watchman.Client();\n\nvar dir_of_interest = \"/some/path\";\n\nclient.capabilityCheck({optional:[], required:['relative_root']},\n  function (error, resp) {\n    if (error) {\n      console.log(error);\n      client.end();\n      return;\n    }\n\n    // Initiate the watch\n    client.command(['watch-project', dir_of_interest],\n      function (error, resp) {\n        if (error) {\n          console.error('Error initiating watch:', error);\n          return;\n        }\n\n        // It is considered to be best practice to show any 'warning' or\n        // 'error' information to the user, as it may suggest steps\n        // for remediation\n        if ('warning' in resp) {\n          console.log('warning: ', resp.warning);\n        }\n\n        // `watch-project` can consolidate the watch for your\n        // dir_of_interest with another watch at a higher level in the\n        // tree, so it is very important to record the `relative_path`\n        // returned in resp\n\n        console.log('watch established on ', resp.watch,\n                    ' relative_path', resp.relative_path);\n      });\n  });\n")),(0,a.mdx)("h2",{id:"subscribing-to-changes"},"Subscribing to changes"),(0,a.mdx)("p",null,"Most node applications are interested in subscribing to live file change\nnotifications. In watchman these are configured by issuing a\n",(0,a.mdx)("a",{parentName:"p",href:"/watchman/docs/cmd/subscribe"},"subscribe")," command. A subscription is valid for the duration\nof your client connection, or until you cancel the subscription using the\n",(0,a.mdx)("a",{parentName:"p",href:"/watchman/docs/cmd/unsubscribe"},"unsubscribe")," command."),(0,a.mdx)("p",null,"The following will generate subscription results for all files in the tree that\nmatch the query expression and then generate subscription results as files\nchange:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"// `watch` is obtained from `resp.watch` in the `watch-project` response.\n// `relative_path` is obtained from `resp.relative_path` in the\n// `watch-project` response.\nfunction make_subscription(client, watch, relative_path) {\n  sub = {\n    // Match any `.js` file in the dir_of_interest\n    expression: [\"allof\", [\"match\", \"*.js\"]],\n    // Which fields we're interested in\n    fields: [\"name\", \"size\", \"mtime_ms\", \"exists\", \"type\"]\n  };\n  if (relative_path) {\n    sub.relative_root = relative_path;\n  }\n\n  client.command(['subscribe', watch, 'mysubscription', sub],\n    function (error, resp) {\n      if (error) {\n        // Probably an error in the subscription criteria\n        console.error('failed to subscribe: ', error);\n        return;\n      }\n      console.log('subscription ' + resp.subscribe + ' established');\n    });\n\n  // Subscription results are emitted via the subscription event.\n  // Note that this emits for all subscriptions.  If you have\n  // subscriptions with different `fields` you will need to check\n  // the subscription name and handle the differing data accordingly.\n  // `resp`  looks like this in practice:\n  //\n  // { root: '/private/tmp/foo',\n  //   subscription: 'mysubscription',\n  //   files: [ { name: 'node_modules/fb-watchman/index.js',\n  //       size: 4768,\n  //       exists: true,\n  //       type: 'f' } ] }\n  client.on('subscription', function (resp) {\n    if (resp.subscription !== 'mysubscription') return;\n\n    resp.files.forEach(function (file) {\n      // convert Int64 instance to javascript integer\n      const mtime_ms = +file.mtime_ms;\n\n      console.log('file changed: ' + file.name, mtime_ms);\n    });\n  });\n}\n")),(0,a.mdx)("h3",{id:"subscribing-only-to-changed-files"},"Subscribing only to changed files"),(0,a.mdx)("p",null,"The example above will generate results for existing (and deleted!) files at the\ntime that the subscription is established. In some applications this can be\nundesirable. The following example shows how to add a logical time constraint."),(0,a.mdx)("p",null,"watchman tracks changes using an ",(0,a.mdx)("a",{parentName:"p",href:"/watchman/docs/clockspec"},"abstract clock"),". We'll determine\nthe current clock at the time that we initiate the watch and then add that as a\nconstraint in our subscription."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},'function make_time_constrained_subscription(client, watch, relative_path) {\n  client.command([\'clock\', watch], function (error, resp) {\n    if (error) {\n      console.error(\'Failed to query clock:\', error);\n      return;\n    }\n\n    sub = {\n      // Match any `.js` file in the dir_of_interest\n      expression: ["allof", ["match", "*.js"]],\n      // Which fields we\'re interested in\n      fields: ["name", "size", "exists", "type"],\n      // add our time constraint\n      since: resp.clock\n    };\n\n    if (relative_path) {\n      sub.relative_root = relative_path;\n    }\n\n    client.command([\'subscribe\', watch, \'mysubscription\', sub],\n      function (error, resp) {\n        // handle the result here\n      });\n  });\n}\n')),(0,a.mdx)("h2",{id:"nodejs-api-reference"},"NodeJS API Reference"),(0,a.mdx)("h2",{id:"methods"},"Methods"),(0,a.mdx)("h3",{id:"clientcapabilitycheckoptions-done"},"client.capabilityCheck(options, done)"),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"capabilityCheck")," method issues a ",(0,a.mdx)("a",{parentName:"p",href:"/watchman/docs/cmd/version"},"version")," command to query\nthe capabilities of the server."),(0,a.mdx)("p",null,"If the server doesn't support capabilities, ",(0,a.mdx)("inlineCode",{parentName:"p"},"capabilityCheck")," will emulate the\ncapability response for a handful of significant capabilities based on the\nversion reported by the server."),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"options")," argument may contain the following properties:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"optional")," an array listing optional capability names"),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"required")," an array listing required capability names")),(0,a.mdx)("p",null,"The properties are passed through to the underlying ",(0,a.mdx)("inlineCode",{parentName:"p"},"version")," command."),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"done")," parameter is a callback that will be passed (error, result) when the\ncommand completes. It doesn't make sense to issue a ",(0,a.mdx)("inlineCode",{parentName:"p"},"capabilityCheck")," call and\nnot provide the ",(0,a.mdx)("inlineCode",{parentName:"p"},"done")," callback."),(0,a.mdx)("p",null,"The response object will contain a ",(0,a.mdx)("inlineCode",{parentName:"p"},"capabilities")," object property whose keys\nwill be the union of the ",(0,a.mdx)("inlineCode",{parentName:"p"},"optional")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"required")," capability names and whose\nvalues will be either ",(0,a.mdx)("inlineCode",{parentName:"p"},"true")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"false")," depending on the availability of the\ncapability name."),(0,a.mdx)("p",null,"If any of the ",(0,a.mdx)("inlineCode",{parentName:"p"},"required")," capabilities are not supported by the server, the\n",(0,a.mdx)("inlineCode",{parentName:"p"},"error")," parameter in the ",(0,a.mdx)("inlineCode",{parentName:"p"},"done")," callback will be set and will contain a\nmeaningful error message."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"client.capabilityCheck({optional:[], required:['relative_root']},\n  function (error, resp) {\n    if (error) {\n      // error will be an Error object if the watchman service is not\n      // installed, or if any of the names listed in the `required`\n      // array are not supported by the server\n      console.error(error);\n    }\n    // resp will be an extended version response:\n    // {'version': '3.8.0', 'capabilities': {'relative_root': true}}\n    console.log(resp);\n  });\n")),(0,a.mdx)("h3",{id:"clientcommandargs--done"},"client.command(args ","[, done]",")"),(0,a.mdx)("p",null,"Sends a command to the watchman service. ",(0,a.mdx)("inlineCode",{parentName:"p"},"args")," is an array that specifies the\ncommand name and any optional arguments. The command is queued and dispatched\nasynchronously. You may queue multiple commands to the service; they will be\ndispatched in FIFO order once the client connection is established."),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"done")," parameter is a callback that will be passed (error, result) when the\ncommand completes. You may omit it if you are not interested in the result of\nthe command."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"client.command(['watch-project', process.cwd()], function(error, resp) {\n  if (error) {\n    console.log('watch failed: ', error);\n    return;\n  }\n  if ('warning' in resp) {\n    console.log('warning: ', resp.warning);\n  }\n  if ('relative_path' in resp) {\n    // We will need to remember and adjust for relative_path\n    console.log('watching project ', resp.watch, ' relative path to cwd is ',\n      resp.relative_path);\n  } else {\n    console.log('watching ', resp.watch);\n  }\n});\n")),(0,a.mdx)("p",null,"If a field named ",(0,a.mdx)("inlineCode",{parentName:"p"},"warning")," is present in ",(0,a.mdx)("inlineCode",{parentName:"p"},"resp"),", the watchman service is trying\nto communicate an issue that the user should see and address. For example, if\nthe system watch resources need adjustment, watchman will provide information\nabout this and how to remediate the issue. It is suggested that tools that build\non top of this library bubble the warning message up to the user."),(0,a.mdx)("h3",{id:"clientend"},"client.end()"),(0,a.mdx)("p",null,"Terminates the connection to the watchman service. Does not wait for any queued\ncommands to send."),(0,a.mdx)("h2",{id:"events"},"Events"),(0,a.mdx)("p",null,"The following events are emitted by the watchman client object:"),(0,a.mdx)("h3",{id:"event-connect"},"Event: 'connect'"),(0,a.mdx)("p",null,"Emitted when the client successfully connects to the watchman service"),(0,a.mdx)("h3",{id:"event-error"},"Event: 'error'"),(0,a.mdx)("p",null,"Emitted when the socket to the watchman service encounters an error."),(0,a.mdx)("p",null,"It may also be emitted prior to establishing a connection if we are unable to\nsuccessfully execute the watchman CLI binary to determine how to talk to the\nserver process."),(0,a.mdx)("p",null,"It is passed a variable that encapsulates the error."),(0,a.mdx)("h3",{id:"event-end"},"Event: 'end'"),(0,a.mdx)("p",null,"Emitted when the socket to the watchman service is closed"),(0,a.mdx)("h3",{id:"event-log"},"Event: 'log'"),(0,a.mdx)("p",null,"Emitted in response to a unilateral ",(0,a.mdx)("inlineCode",{parentName:"p"},"log")," PDU from the watchman service. To\nenable these, you need to send a ",(0,a.mdx)("inlineCode",{parentName:"p"},"log-level")," command to the service:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"// This is very verbose, you probably don't want to do this\nclient.command(['log-level', 'debug']);\nclient.on('log', function(info) {\n  console.log(info);\n});\n")),(0,a.mdx)("h3",{id:"event-subscription"},"Event: 'subscription'"),(0,a.mdx)("p",null,"Emitted in response to a unilateral ",(0,a.mdx)("inlineCode",{parentName:"p"},"subscription")," PDU from the watchman\nservice. To enable these, you need to send a ",(0,a.mdx)("inlineCode",{parentName:"p"},"subscribe")," command to the service:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"  // Subscribe to notifications about .js files\n  client.command(['subscribe', process.cwd(), 'mysubscription', {\n      expression: [\"match\", \"*.js\"]\n    }],\n    function(error, resp) {\n      if (error) {\n        // Probably an error in the subscription criteria\n        console.log('failed to subscribe: ', error);\n        return;\n      }\n      console.log('subscription ' + resp.subscribe + ' established');\n    }\n  );\n\n  // Subscription results are emitted via the subscription event.\n  // Note that watchman will deliver a list of all current files\n  // when you first subscribe, so you don't need to walk the tree\n  // for yourself on startup\n  client.on('subscription', function(resp) {\n    console.log(resp.root, resp.subscription, resp.files);\n  });\n")),(0,a.mdx)("p",null,"To cancel a subscription, use the ",(0,a.mdx)("inlineCode",{parentName:"p"},"unsubscribe")," command and pass in the name of\nthe subscription you want to cancel:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"  client.command(['unsubscribe', process.cwd(), 'mysubscription']);\n")),(0,a.mdx)("p",null,"Note that subscriptions names are scoped to your connection to the watchman\nservice; multiple different clients can use the same subscription name without\nfear of colliding."))}u.isMDXComponent=!0}}]);